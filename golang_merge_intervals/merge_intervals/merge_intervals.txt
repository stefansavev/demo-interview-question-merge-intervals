package merge_intervals

import (
	"sort"
)

type Interval struct {
	Start int
	End   int
}

type Intervals []Interval

func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}

func copyIntervalsAsPtrs(intervals Intervals) []*Interval {
	cp := make([]*Interval, len(intervals))
	for i, interval := range intervals{
		cp[i] = &Interval{Start: interval.Start, End: interval.End}
	}
	return cp
}

func tryMerge(firstInterval *Interval, secondInterval *Interval) (bool, *Interval) {
	if secondInterval.Start <= firstInterval.End {
		return true, &Interval{
			Start: min(firstInterval.Start, secondInterval.Start),
			End:   max(firstInterval.End, secondInterval.End),
		}
	}
	return false, nil
}

type byIntervalStart []*Interval
func (a byIntervalStart) Len() int           { return len(a) }
func (a byIntervalStart) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a byIntervalStart) Less(i, j int) bool { return a[i].Start < a[j].Start }

func MergeIntervals(intervals Intervals) Intervals {
	sortedIntervals := copyIntervalsAsPtrs(intervals)
	sort.Sort(byIntervalStart(sortedIntervals))
	var current *Interval = nil
	var output []Interval = make(Intervals, 0)
	for _, intervalPtr := range sortedIntervals {
		if current == nil {
			current = intervalPtr
		} else {
			ok, mergedInterval := tryMerge(current, intervalPtr)
			if ok {
				current = mergedInterval
			} else {
				output = append(output, *current)
				current = intervalPtr
			}
		}
	}
	if current != nil {
		output = append(output, *current)
	}
	return output
}
